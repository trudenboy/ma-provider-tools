#!/usr/bin/env python3
"""Distribute wrapper workflow files to all provider repos.

Reads providers.yml, renders Jinja2 wrapper templates for each provider,
then creates PRs in each provider repo with the updated wrapper files.

Usage:
    python3 scripts/distribute.py

Requires:
    - GH_TOKEN env var with a PAT that has contents:write on all provider repos
    - jinja2 installed (pip install jinja2)
    - gh CLI available
"""

from __future__ import annotations

import json
import os
import subprocess
import sys
import tempfile
from pathlib import Path

import yaml

try:
    from jinja2 import Environment, FileSystemLoader, StrictUndefined
except ImportError:
    print("ERROR: jinja2 not installed. Run: pip install jinja2", file=sys.stderr)
    sys.exit(1)

REPO_ROOT = Path(__file__).parent.parent
PROVIDERS_FILE = REPO_ROOT / "providers.yml"
WRAPPERS_DIR = REPO_ROOT / "wrappers"
BRANCH_NAME = "chore/update-workflow-wrappers"
PR_TITLE = "chore: sync workflow wrappers from ma-provider-tools"
PR_BODY = """\
## Automated wrapper update

Workflow wrappers updated from [trudenboy/ma-provider-tools](https://github.com/trudenboy/ma-provider-tools).

These wrapper files delegate all logic to the shared reusable workflows in `ma-provider-tools`,
so updating them here keeps provider repos in sync with the central workflow registry.

---
*This PR was auto-generated by `ma-provider-tools/scripts/distribute.py`.*
"""

WORKFLOW_FILES = [
    ("sync-to-fork.yml.j2", ".github/workflows/sync-to-fork.yml"),
    ("release.yml.j2", ".github/workflows/release.yml"),
    ("test.yml.j2", ".github/workflows/test.yml"),
]


def run(cmd: list[str], cwd: str | None = None, check: bool = True) -> subprocess.CompletedProcess[str]:
    """Run a shell command and return the result."""
    return subprocess.run(cmd, cwd=cwd, capture_output=True, text=True, check=check)


def render_wrappers(provider: dict) -> dict[str, str]:
    """Render all wrapper templates for a provider and return {dest_path: content}."""
    env = Environment(
        loader=FileSystemLoader(str(WRAPPERS_DIR)),
        undefined=StrictUndefined,
        keep_trailing_newline=True,
    )

    context = {
        "domain": provider["domain"],
        "manifest_path": provider["manifest_path"],
        "provider_path": provider["provider_path"],
        "provider_type": provider["provider_type"],
    }

    result: dict[str, str] = {}
    for template_name, dest_path in WORKFLOW_FILES:
        template = env.get_template(template_name)
        result[dest_path] = template.render(**context)

    return result


def create_pr_for_provider(provider: dict, dry_run: bool = False) -> None:
    """Clone provider repo, apply wrapper updates, and create a PR."""
    repo = provider["repo"]
    branch = provider["default_branch"]
    domain = provider["domain"]

    print(f"\n{'='*60}")
    print(f"Processing {repo} ({domain})")
    print(f"{'='*60}")

    rendered = render_wrappers(provider)

    with tempfile.TemporaryDirectory() as tmpdir:
        # Clone the repo
        print(f"Cloning {repo}...")
        run(["gh", "repo", "clone", repo, tmpdir, "--", "--depth=1", f"--branch={branch}"])

        # Configure git and inject token into remote URL so git push authenticates
        token = os.environ.get("GH_TOKEN", "")
        run(["git", "config", "user.name", "github-actions[bot]"], cwd=tmpdir)
        run(["git", "config", "user.email", "github-actions[bot]@users.noreply.github.com"], cwd=tmpdir)
        if token:
            run(
                ["git", "remote", "set-url", "origin", f"https://x-access-token:{token}@github.com/{repo}.git"],
                cwd=tmpdir,
            )

        # Check if update branch already exists
        result = run(["git", "ls-remote", "--heads", "origin", BRANCH_NAME], cwd=tmpdir, check=False)
        branch_exists = bool(result.stdout.strip())

        if branch_exists:
            run(["git", "checkout", BRANCH_NAME], cwd=tmpdir)
        else:
            run(["git", "checkout", "-b", BRANCH_NAME], cwd=tmpdir)

        # Write rendered wrapper files
        changed = False
        for dest_path, content in rendered.items():
            dest = Path(tmpdir) / dest_path
            dest.parent.mkdir(parents=True, exist_ok=True)
            existing = dest.read_text() if dest.exists() else None
            if existing != content:
                dest.write_text(content)
                run(["git", "add", dest_path], cwd=tmpdir)
                changed = True
                print(f"  Updated: {dest_path}")
            else:
                print(f"  Unchanged: {dest_path}")

        # Remove legacy files that are superseded by wrapper files
        for legacy_path in provider.get("legacy_files", []):
            legacy = Path(tmpdir) / legacy_path
            if legacy.exists():
                legacy.unlink()
                run(["git", "rm", legacy_path], cwd=tmpdir)
                changed = True
                print(f"  Removed legacy: {legacy_path}")

        if not changed:
            print(f"  No changes needed for {repo}, skipping PR.")
            return

        if dry_run:
            print(f"  [DRY RUN] Would commit and create PR for {repo}")
            return

        # Commit
        run(
            ["git", "commit", "-m", "chore: sync workflow wrappers from ma-provider-tools"],
            cwd=tmpdir,
        )

        # Push
        push_args = ["git", "push", "origin", BRANCH_NAME]
        if branch_exists:
            push_args.append("--force-with-lease")
        run(push_args, cwd=tmpdir)

        # Check if PR already exists
        existing_pr = run(
            ["gh", "pr", "view", BRANCH_NAME, "--repo", repo, "--json", "url", "-q", ".url"],
            cwd=tmpdir,
            check=False,
        )

        if existing_pr.returncode == 0 and existing_pr.stdout.strip():
            pr_url = existing_pr.stdout.strip()
            print(f"  PR already exists: {pr_url} (updated with force push)")
        else:
            result = run(
                [
                    "gh", "pr", "create",
                    "--repo", repo,
                    "--title", PR_TITLE,
                    "--body", PR_BODY,
                    "--base", branch,
                    "--head", BRANCH_NAME,
                ],
                cwd=tmpdir,
            )
            pr_url = result.stdout.strip()
            print(f"  PR created: {pr_url}")


def main() -> None:
    dry_run = "--dry-run" in sys.argv

    if not PROVIDERS_FILE.exists():
        print(f"ERROR: {PROVIDERS_FILE} not found", file=sys.stderr)
        sys.exit(1)

    if not os.environ.get("GH_TOKEN") and not dry_run:
        print("ERROR: GH_TOKEN environment variable not set", file=sys.stderr)
        sys.exit(1)

    registry = yaml.safe_load(PROVIDERS_FILE.read_text())
    providers = registry.get("providers", [])

    if not providers:
        print("No providers found in providers.yml", file=sys.stderr)
        sys.exit(1)

    print(f"Distributing wrappers to {len(providers)} provider repos...")
    if dry_run:
        print("[DRY RUN MODE â€” no PRs will be created]\n")

    for provider in providers:
        try:
            create_pr_for_provider(provider, dry_run=dry_run)
        except subprocess.CalledProcessError as e:
            print(f"ERROR processing {provider['repo']}: {e.stderr}", file=sys.stderr)
            if not dry_run:
                raise

    print("\nDone.")


if __name__ == "__main__":
    main()
