#!/usr/bin/env python3
"""Distribute wrapper workflow files to all provider repos.

Reads providers.yml, renders Jinja2 wrapper templates for each provider,
then creates PRs in each provider repo with the updated wrapper files.

Usage:
    python3 scripts/distribute.py

Requires:
    - GH_TOKEN env var with a PAT that has contents:write on all provider repos
    - jinja2 installed (pip install jinja2)
    - gh CLI available
"""

from __future__ import annotations

import os
import subprocess
import sys
import tempfile
from pathlib import Path

import yaml

try:
    from jinja2 import Environment, FileSystemLoader, StrictUndefined
except ImportError:
    print("ERROR: jinja2 not installed. Run: pip install jinja2", file=sys.stderr)
    sys.exit(1)

REPO_ROOT = Path(__file__).parent.parent
PROVIDERS_FILE = REPO_ROOT / "providers.yml"
WRAPPERS_DIR = REPO_ROOT / "wrappers"
BRANCH_NAME = "chore/update-workflow-wrappers"
PR_TITLE = "chore: sync workflow wrappers from ma-provider-tools"
PR_BODY = """\
## Automated wrapper update

Workflow wrappers updated from [trudenboy/ma-provider-tools](https://github.com/trudenboy/ma-provider-tools).

These wrapper files delegate all logic to the shared reusable workflows in `ma-provider-tools`,
so updating them here keeps provider repos in sync with the central workflow registry.

---
*This PR was auto-generated by `ma-provider-tools/scripts/distribute.py`.*
"""

ALL_WRAPPER_FILES = [
    # CI workflows
    ("sync-to-fork.yml.j2", ".github/workflows/sync-to-fork.yml"),
    ("release.yml.j2", ".github/workflows/release.yml"),
    ("test.yml.j2", ".github/workflows/test.yml"),
    ("security.yml.j2", ".github/workflows/security.yml"),
    # Label management
    ("sync-labels.yml.j2", ".github/workflows/sync-labels.yml"),
    ("labels.yml.j2", ".github/labels.yml"),
    # Copilot triage
    ("copilot-triage.yml.j2", ".github/workflows/copilot-triage.yml"),
    # Security policy
    ("SECURITY.md.j2", "SECURITY.md"),
    # Issue templates
    ("issue-bug.yml.j2", ".github/ISSUE_TEMPLATE/bug_report.yml"),
    ("issue-upstream.yml.j2", ".github/ISSUE_TEMPLATE/upstream_api_change.yml"),
    ("issue-proposal.yml.j2", ".github/ISSUE_TEMPLATE/improvement_proposal.yml"),
    ("issue-config.yml.j2", ".github/ISSUE_TEMPLATE/config.yml"),
    # Documentation
    ("contributing.md.j2", "docs/contributing.md"),
    # Project automation
    ("issue-project.yml.j2", ".github/workflows/issue-project.yml"),
    # Ruff configuration
    ("ruff.toml.j2", "ruff.toml"),
    # Docker dev environment
    ("docker-compose.dev.yml.j2", "docker-compose.dev.yml"),
    ("scripts/docker-init.sh.j2", "scripts/docker-init.sh"),
    ("docs/dev-docker.md.j2", "docs/dev-docker.md"),
    # Testing and incident management docs
    ("docs/testing.md.j2", "docs/testing.md"),
    ("docs/incident-management.md.j2", "docs/incident-management.md"),
    # PR template
    (".github/PULL_REQUEST_TEMPLATE.md.j2", ".github/PULL_REQUEST_TEMPLATE.md"),
    # Fork upstream sync (server_fork only)
    ("sync-from-upstream.yml.j2", ".github/workflows/sync-from-upstream.yml"),
    # GitHub Pages documentation
    ("docs.yml.j2", ".github/workflows/docs.yml"),
    ("mkdocs.yml.j2", "mkdocs.yml"),
    ("docs/index.md.j2", "docs/index.md"),
    ("docs/known-issues.md.j2", "docs/known-issues.md"),
]


def run(
    cmd: list[str], cwd: str | None = None, check: bool = True
) -> subprocess.CompletedProcess[str]:
    """Run a shell command and return the result."""
    return subprocess.run(cmd, cwd=cwd, capture_output=True, text=True, check=check)


def render_wrappers(provider: dict, all_providers: list[dict]) -> dict[str, str]:
    """Render all wrapper templates for a provider and return {dest_path: content}."""
    env = Environment(
        loader=FileSystemLoader(str(WRAPPERS_DIR)),
        undefined=StrictUndefined,
        keep_trailing_newline=True,
    )

    context = {
        "domain": provider["domain"],
        "display_name": provider.get("display_name", ""),
        "manifest_path": provider.get("manifest_path", ""),
        "provider_path": provider.get("provider_path", ""),
        "provider_type": provider.get("provider_type", ""),
        "locale": provider.get("locale", "en"),
        "repo": provider["repo"],
        "default_branch": provider["default_branch"],
        "all_providers": [
            p for p in all_providers if p.get("provider_type") != "server_fork"
        ],
    }

    skip = set(provider.get("skip_wrappers", []))
    templates = [(t, d) for t, d in ALL_WRAPPER_FILES if t not in skip]

    result: dict[str, str] = {}
    for template_name, dest_path in templates:
        template = env.get_template(template_name)
        result[dest_path] = template.render(**context)

    return result


def create_pr_for_provider(
    provider: dict, all_providers: list[dict], dry_run: bool = False
) -> None:
    """Clone provider repo, apply wrapper updates, and create a PR."""
    repo = provider["repo"]
    branch = provider["default_branch"]
    domain = provider["domain"]

    print(f"\n{'=' * 60}")
    print(f"Processing {repo} ({domain})")
    print(f"{'=' * 60}")

    rendered = render_wrappers(provider, all_providers)

    with tempfile.TemporaryDirectory() as tmpdir:
        # Clone the repo
        print(f"Cloning {repo}...")
        run(
            [
                "gh",
                "repo",
                "clone",
                repo,
                tmpdir,
                "--",
                "--depth=1",
                f"--branch={branch}",
            ]
        )

        # Configure git and inject credentials via GH_TOKEN environment variable
        token = os.environ.get("GH_TOKEN", "")
        run(["git", "config", "user.name", "github-actions[bot]"], cwd=tmpdir)
        run(
            [
                "git",
                "config",
                "user.email",
                "github-actions[bot]@users.noreply.github.com",
            ],
            cwd=tmpdir,
        )
        if token:
            run(
                [
                    "git",
                    "config",
                    "--global",
                    f"url.https://x-access-token:{token}@github.com/.insteadOf",
                    "https://github.com/",
                ],
                cwd=tmpdir,
            )

        # Always create branch fresh from default_branch. Checking out from the
        # existing remote branch accumulates commits across runs; when squash-merged
        # into the default branch the old and new commits cancel each other out,
        # producing a net-zero diff and leaving provider repos unchanged.
        run(["git", "checkout", "-b", BRANCH_NAME], cwd=tmpdir)

        # Write rendered wrapper files
        changed = False
        for dest_path, content in rendered.items():
            dest = Path(tmpdir) / dest_path
            dest.parent.mkdir(parents=True, exist_ok=True)
            existing = dest.read_text() if dest.exists() else None
            if existing != content:
                dest.write_text(content)
                run(["git", "add", dest_path], cwd=tmpdir)
                if dest_path.endswith(".sh"):
                    run(["git", "update-index", "--chmod=+x", dest_path], cwd=tmpdir)
                changed = True
                print(f"  Updated: {dest_path}")
            else:
                print(f"  Unchanged: {dest_path}")

        # Remove legacy files that are superseded by wrapper files
        for legacy_path in provider.get("legacy_files", []):
            legacy = Path(tmpdir) / legacy_path
            if legacy.exists():
                legacy.unlink()
                run(["git", "rm", legacy_path], cwd=tmpdir)
                changed = True
                print(f"  Removed legacy: {legacy_path}")

        if not changed:
            print(f"  No changes needed for {repo}, skipping PR.")
            return

        if dry_run:
            print(f"  [DRY RUN] Would commit and create PR for {repo}")
            return

        # Commit
        run(
            [
                "git",
                "commit",
                "-m",
                "chore: sync workflow wrappers from ma-provider-tools",
            ],
            cwd=tmpdir,
        )

        # Push (force is safe: this is a bot-owned throwaway branch)
        run(["git", "push", "--force", "origin", BRANCH_NAME], cwd=tmpdir)

        # Check if an OPEN PR already exists for this branch.
        # gh pr view also returns merged/closed PRs, so we use gh pr list
        # with --state open to avoid mistaking a merged PR for an active one.
        existing_pr = run(
            [
                "gh",
                "pr",
                "list",
                "--repo",
                repo,
                "--head",
                BRANCH_NAME,
                "--state",
                "open",
                "--json",
                "url",
                "-q",
                ".[0].url",
            ],
            cwd=tmpdir,
            check=False,
        )

        if existing_pr.returncode == 0 and existing_pr.stdout.strip():
            pr_url = existing_pr.stdout.strip()
            print(f"  PR already exists: {pr_url} (updated with force push)")
        else:
            result = run(
                [
                    "gh",
                    "pr",
                    "create",
                    "--repo",
                    repo,
                    "--title",
                    PR_TITLE,
                    "--body",
                    PR_BODY,
                    "--base",
                    branch,
                    "--head",
                    BRANCH_NAME,
                ],
                cwd=tmpdir,
            )
            pr_url = result.stdout.strip()
            print(f"  PR created: {pr_url}")

        # Enable auto-merge and auto-delete branches on the repo
        run(
            [
                "gh",
                "api",
                f"repos/{repo}",
                "--method",
                "PATCH",
                "--field",
                "allow_auto_merge=true",
                "--field",
                "delete_branch_on_merge=true",
            ],
            cwd=tmpdir,
            check=False,
        )
        auto = run(
            ["gh", "pr", "merge", "--auto", "--squash", "--repo", repo, pr_url],
            cwd=tmpdir,
            check=False,
        )
        if auto.returncode == 0:
            print("  Auto-merge enabled (squash)")
        else:
            print(
                f"  Warning: could not enable auto-merge: {auto.stderr.strip()}",
                file=sys.stderr,
            )


def main() -> None:
    dry_run = "--dry-run" in sys.argv

    if not PROVIDERS_FILE.exists():
        print(f"ERROR: {PROVIDERS_FILE} not found", file=sys.stderr)
        sys.exit(1)

    if not os.environ.get("GH_TOKEN") and not dry_run:
        print("ERROR: GH_TOKEN environment variable not set", file=sys.stderr)
        sys.exit(1)

    registry = yaml.safe_load(PROVIDERS_FILE.read_text())
    providers = registry.get("providers", [])

    if not providers:
        print("No providers found in providers.yml", file=sys.stderr)
        sys.exit(1)

    print(f"Distributing wrappers to {len(providers)} provider repos...")
    if dry_run:
        print("[DRY RUN MODE â€” no PRs will be created]\n")

    os.environ["GIT_TERMINAL_PROMPT"] = "0"

    errors: list[str] = []
    for provider in providers:
        try:
            create_pr_for_provider(provider, providers, dry_run=dry_run)
        except subprocess.CalledProcessError as e:
            print(f"ERROR processing {provider['repo']}: {e.stderr}", file=sys.stderr)
            errors.append(provider["repo"])

    if errors:
        print(
            f"\nFailed providers ({len(errors)}): {', '.join(errors)}", file=sys.stderr
        )
        sys.exit(1)

    print("\nDone.")


if __name__ == "__main__":
    main()
